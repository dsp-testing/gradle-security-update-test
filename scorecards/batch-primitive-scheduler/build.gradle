apply plugin: 'us.datanerd.java-service'
apply plugin: 'us.datanerd.application'
apply plugin: 'us.datanerd.docker'
apply plugin: 'us.datanerd.dependency-license-manifest'
apply plugin: 'us.datanerd.static-analysis'
apply plugin: 'us.datanerd.coverage'
apply plugin: 'us.datanerd.coverage-report'
apply plugin: 'checkstyle'
apply plugin: 'org.flywaydb.flyway'

application {
    name 'batch-primitive-scheduler'
    mainClass 'com.newrelic.batchprimitivescheduler.BatchPrimitiveSchedulerApplication'
    port 8080 // Should correspond with src/dist/config/server.yml
    usingSimpleControlScripts true
    usingFips(ACCP: libs.versions.accp.get())
}

buildscript {
    dependencies {
        classpath (libs.flyway.gradle.plugin) {
            exclude module: 'flyway-database-oracle'
        }
        classpath libs.postgres
        // This enables cli usage of flyway
        classpath libs.flyway.database.postgresql
    }
}

docker {
    name 'cf-registry.nr-ops.net/scorecards/batch-primitive-scheduler'
    ports application.port
    build {
        from 'cf-registry.nr-ops.net/newrelic/ubuntu-2204-java:21'
        maintainer 'scorecards <nos@newrelic.com>'
        label 'application', application.name
        user { hashed = true }
    }
    run {
        envVars << [MARATHON_APP_RESOURCE_CPUS: '1']
        envVars << [JAVA_ARGS: 'server /data/batch-primitive-scheduler/config/server.yml']
    }
}

agent.version = libs.versions.newrelic.get()

configurations.configureEach {
    // why we do this: https://source.datanerd.us/gist/tom/77ed8974f0ac0b93b592
    exclude module: 'slf4j-log4j12'
    exclude group: 'log4j'
    exclude module: 'commons-logging'

    resolutionStrategy {
        force libs.newrelic.api
    }
}

dependencies {
    annotationProcessor libs.dagger.compiler
    testAnnotationProcessor libs.dagger.compiler

    //
    // implementation: on your classpath at compile time, runtime and in tests
    //

    implementation platform(libs.newrelic.idiomancer.bom)
    implementation libs.newrelic.idiomancer.core
    implementation libs.newrelic.idiomancer.dagger2
    implementation libs.newrelic.pg.jdbi

    implementation libs.dagger.runtime
    implementation libs.dropwizard.configuration
    implementation libs.dropwizard.core
    implementation libs.dropwizard.metrics.healthchecks
    implementation libs.guava
    implementation libs.newrelic.autoservices
    implementation libs.slf4j.api
    implementation libs.apache.curator.recipes
    implementation libs.flyway.core
    implementation libs.flyway.database.postgresql
    implementation libs.postgres
    implementation libs.bucket4j.core

    implementation platform(libs.newrelic.kafka.clients.bom)
    implementation libs.newrelic.kafka.clients.autoservices
    implementation libs.batch.primitive.models

    implementation libs.newrelic.feature.flag.client


    //UsageHeaders constants only
    implementation (libs.newrelic.usage.client) {
        transitive = false
    }

    //
    // runtime: on your classpath at runtime and in tests
    //
    runtimeOnly libs.logback.classic
    runtimeOnly libs.logback.core
    runtimeOnly libs.slf4j.log4j.over.slf4j
    runtimeOnly libs.slf4j.jcl.over.slf4j

    testImplementation platform(libs.assertj.bom)
    testImplementation libs.assertj.core

    testImplementation libs.dropwizard.client
    testImplementation libs.dropwizard.testing

    testImplementation platform(libs.testcontainers.bom)
    testImplementation libs.testcontainers.junit.jupiter
    testImplementation libs.testcontainers.kafka
    testImplementation libs.testcontainers.postgresql

    testImplementation libs.mockito.core
    testImplementation libs.mockito.junit.jupiter

    //
    // newrelic-kafka-clients-enhancements
    //
    // Custom extension for the New Relic Java Agent that improves the Kafka client monitoring functionality
    // provided by the agent. Data generated by this extension also drives the 'Kafka' APM Nerdlet for your
    // service, giving teams producer and consumer metrics from day one.
    //
    // (It does no harm to leave this in place even if you don't currently use Kafka.)
    //
    agentExtension libs.newrelic.kafka.clients.enhancements

    constraints {
        implementation(libs.commons.httpclient) {
            because 'example of reconciling mixed versions of a transitive dependency'
        }
    }
}

testing {
    suites {
        test {
            useJUnitJupiter(libs.versions.junit.get())
        }
    }
}

flyway {
    url = System.getenv('SCHEDULES_DB_URL')
            ? "jdbc:${System.getenv('SCHEDULES_DB_URL')}"
            : 'jdbc:postgresql://localhost:5432/schedules_local'
    user = System.getenv("SCHEDULES_DB_MIGRATION_USER") ?: "batch_primitive_scheduler"
    password = System.getenv("SCHEDULES_DB_MIGRATION_PASSWORD") ?: "password"
    cleanDisabled = true

    // Prevent wiping the database running gradlew flywayClean
    // for all databases except local/unit tests docker image
    if (url.contains("localhost") && url.contains("schedules_local")) {
        logger.info("Enabling flyway clean for local database $url")
        cleanDisabled = false
    }
    locations = ['classpath:db/migration',
                 'classpath:db/production',
                 'classpath:db/eu-production']
}
coverage {
    element 'BUNDLE'
    fileThreshold 0.5
    generatedSources = ['**/Dagger*Component*', '**/*_*Factory*']
}

coverageReport {
    eventEnabled true
    badgeEnabled true
    aspirationalInstructionThreshold 0.80
}

tasks.withType(Checkstyle) {
    configDirectory = file("$rootProject.projectDir/config/checkstyle")
    ignoreFailures = false
}

